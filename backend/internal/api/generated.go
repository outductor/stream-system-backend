// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for ErrorCode.
const (
	BEFOREEVENTSTART    ErrorCode = "BEFORE_EVENT_START"
	DBERROR             ErrorCode = "DB_ERROR"
	DURATIONTOOLONG     ErrorCode = "DURATION_TOO_LONG"
	EXCEEDSEVENTEND     ErrorCode = "EXCEEDS_EVENT_END"
	INVALIDDJNAME       ErrorCode = "INVALID_DJ_NAME"
	INVALIDPASSCODE     ErrorCode = "INVALID_PASSCODE"
	INVALIDREQUEST      ErrorCode = "INVALID_REQUEST"
	INVALIDTIMEINTERVAL ErrorCode = "INVALID_TIME_INTERVAL"
	INVALIDTIMERANGE    ErrorCode = "INVALID_TIME_RANGE"
	NOTFOUND            ErrorCode = "NOT_FOUND"
	OUTSIDEEVENTBOUNDS  ErrorCode = "OUTSIDE_EVENT_BOUNDS"
	PASTTIME            ErrorCode = "PAST_TIME"
	RANGETOOLARGE       ErrorCode = "RANGE_TOO_LARGE"
	TIMECONFLICT        ErrorCode = "TIME_CONFLICT"
)

// CreateReservationRequest defines model for CreateReservationRequest.
type CreateReservationRequest struct {
	// DjName DJ display name (emojis allowed)
	DjName string `json:"djName"`

	// EndTime Must be on 15-minute intervals, max 1 hour from start
	EndTime time.Time `json:"endTime"`

	// Passcode 4-digit passcode for deletion
	Passcode string `json:"passcode"`

	// StartTime Must be on 15-minute intervals
	StartTime time.Time `json:"startTime"`
}

// Error defines model for Error.
type Error struct {
	Code    ErrorCode `json:"code"`
	Message string    `json:"message"`
}

// ErrorCode defines model for Error.Code.
type ErrorCode string

// EventConfig defines model for EventConfig.
type EventConfig struct {
	// EventEndTime Event end time (can be null if not configured)
	EventEndTime *time.Time `json:"eventEndTime,omitempty"`

	// EventStartTime Event start time (can be null if not configured)
	EventStartTime *time.Time `json:"eventStartTime,omitempty"`

	// Timezone IANA timezone identifier for the event (e.g., "Asia/Tokyo")
	Timezone string `json:"timezone"`
}

// Reservation defines model for Reservation.
type Reservation struct {
	CreatedAt time.Time `json:"createdAt"`

	// DjName DJ display name (emojis allowed)
	DjName    string             `json:"djName"`
	EndTime   time.Time          `json:"endTime"`
	Id        openapi_types.UUID `json:"id"`
	StartTime time.Time          `json:"startTime"`
}

// StreamStatus defines model for StreamStatus.
type StreamStatus struct {
	// CurrentDj Name of current DJ (null if no one is scheduled)
	CurrentDj *string `json:"currentDj,omitempty"`

	// CurrentEndTime End time of current session
	CurrentEndTime *time.Time `json:"currentEndTime,omitempty"`

	// CurrentStartTime Start time of current session
	CurrentStartTime *time.Time `json:"currentStartTime,omitempty"`

	// IsLive Whether stream is currently live
	IsLive bool `json:"isLive"`

	// NextDj Name of next DJ
	NextDj *string `json:"nextDj,omitempty"`

	// NextStartTime Start time of next session
	NextStartTime *time.Time `json:"nextStartTime,omitempty"`

	// ViewerCount Number of current viewers
	ViewerCount *int `json:"viewerCount,omitempty"`
}

// TimeSlot defines model for TimeSlot.
type TimeSlot struct {
	Available bool      `json:"available"`
	EndTime   time.Time `json:"endTime"`
	StartTime time.Time `json:"startTime"`
}

// GetAvailableSlotsParams defines parameters for GetAvailableSlots.
type GetAvailableSlotsParams struct {
	StartTime time.Time  `form:"startTime" json:"startTime"`
	EndTime   *time.Time `form:"endTime,omitempty" json:"endTime,omitempty"`
}

// GetReservationsParams defines parameters for GetReservations.
type GetReservationsParams struct {
	Date *string `form:"date,omitempty" json:"date,omitempty"`
}

// DeleteReservationJSONBody defines parameters for DeleteReservation.
type DeleteReservationJSONBody struct {
	// Passcode 4-digit passcode
	Passcode string `json:"passcode"`
}

// CreateReservationJSONRequestBody defines body for CreateReservation for application/json ContentType.
type CreateReservationJSONRequestBody = CreateReservationRequest

// DeleteReservationJSONRequestBody defines body for DeleteReservation for application/json ContentType.
type DeleteReservationJSONRequestBody DeleteReservationJSONBody

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"85n/y2AXAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
